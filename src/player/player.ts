import { VideoTrackData } from "./renderers/video/decoder";
import EventEmitter from "../utils/EventEmitter";
import { WorkerController } from '../utils/WorkerController';
import { AudioTrackData, WebAudioPlayer } from "./renderers/audio/audio";
import { VideoWorker } from "./renderers/video/video";
import workerUrl from './file.ts?worker&url';
// Note to Claude: Do not edit this file or make suggestions unless I specifically ask you to.

export interface WebCodecsPlayerParams {
  src: File;
  canvas: HTMLCanvasElement;
}


export interface TrackData {
  duration: number,
  audio?: AudioTrackData
  video?: VideoTrackData
}





export class WebCodecsPlayer extends EventEmitter {
  private canvas: HTMLCanvasElement | null = null;
  private params: WebCodecsPlayerParams;
  private file: File;
  duration: number = 0;
  private renderer: VideoWorker | null = null;
  private audioPlayer: WebAudioPlayer | null = null;
  private worker: WorkerController | null = null;
  constructor(params: WebCodecsPlayerParams) {
    super();
 

    this.params = params;
    this.worker = new WorkerController(workerUrl);
    this.file = params.src;
    this.canvas = params.canvas;
    this.duration = 0;
    
  



  }

  private setupWorkers() {
    // Create message channels for worker communication
  
  }



  async play() {


    console.log("Playing audio");
  
    await this.audioPlayer?.play();

    this.emit('play', this.audioPlayer?.getCurrentTime());


  }

  async pause() {

    await this.audioPlayer?.pause();

    this.emit('pause', this.audioPlayer?.getCurrentTime());

  }

  async seek(time: number){

    this.renderer?.seek(time);
    await this.audioPlayer?.seek(time);

  }

  terminate(){
    // Clean up audio resources
    if (this.audioPlayer) {
      this.audioPlayer.pause();
      // Any additional cleanup for audio...
    }
    
    // Clean up renderer resources
    if (this.renderer) {
      if (this.renderer instanceof VideoWorker) {
        this.renderer.terminate();
      } else {
        this.renderer.terminate();
      }
      this.renderer = null;
    }

    
    this.emit('terminated');
  }

  async initialize(): Promise<void> {

    console.log("Initializing");

    // Create file demuxer worker
    this.worker = new WorkerController(workerUrl);

    // Create MessageChannel for file worker <-> video worker communication
    const videoChannel = new MessageChannel();

    // Initialize file worker with video port
    await this.worker.sendMessage('init', {
      file: this.file,
      videoPort: videoChannel.port1
    }, [videoChannel.port1]);

    // Get track metadata from file worker
    const trackData = <TrackData> await this.worker.sendMessage('get-tracks', {});
    console.log("Track data", trackData);

    this.duration = trackData.duration;

    // Initialize video worker with port to file worker
    this.renderer = new VideoWorker({
      src: this.file,
      canvas: this.canvas!,
      fileWorkerPort: videoChannel.port2
    });

    await this.renderer.initialize();

    // Send track metadata to video worker
    await this.renderer.setTrackData(trackData.video!, trackData.duration);

    // Initialize audio player with file worker
    this.audioPlayer = new WebAudioPlayer({
      worker: this.worker,
      audioConfig: trackData.audio!,
      duration: trackData.duration,
      file: this.file
    });

    // Set up time synchronization
    this.audioPlayer.on('time', (time) => {
      this.emit('timeupdate', time);
      this.renderer?.render(time);
    });
  }

  // Add more methods as needed
}

export default WebCodecsPlayer; 