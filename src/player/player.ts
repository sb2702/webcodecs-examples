import { VideoTrackData } from "./renderers/video/decoder";
import EventEmitter from "../utils/EventEmitter";
import { WorkerController } from '../utils/WorkerController';
import { AudioTrackData, WebAudioPlayer } from "./renderers/audio/audio";
import { VideoWorker } from "./renderers/video/video";
import { Clock } from "./clock";
import workerUrl from './file.ts?worker&url';
// Note to Claude: Do not edit this file or make suggestions unless I specifically ask you to.

export interface WebCodecsPlayerParams {
  src: File;
  canvas: HTMLCanvasElement;
}


export interface TrackData {
  duration: number,
  audio?: AudioTrackData
  video?: VideoTrackData
}





export class WebCodecsPlayer extends EventEmitter {
  private canvas: HTMLCanvasElement | null = null;
  private params: WebCodecsPlayerParams;
  private file: File;
  duration: number = 0;
  private renderer: VideoWorker | null = null;
  private audioPlayer: WebAudioPlayer | null = null;
  private worker: WorkerController | null = null;
  private clock: Clock | null = null;
  private trackData: TrackData | null = null;

  constructor(params: WebCodecsPlayerParams) {
    super();

    this.params = params;
    this.worker = new WorkerController(workerUrl);
    this.file = params.src;
    this.canvas = params.canvas;
    this.duration = 0;
  }



  async play() {
    if (!this.clock) {
      throw new Error('Player not initialized. Call initialize() first.');
    }

    await this.clock.play();
  }

  async pause() {
    if (!this.clock) {
      throw new Error('Player not initialized. Call initialize() first.');
    }

    this.clock.pause();
  }

  async seek(time: number) {
    if (!this.clock) {
      throw new Error('Player not initialized. Call initialize() first.');
    }

    await this.clock.seek(time);
  }

  getCurrentTime(): number {
    return this.clock?.getCurrentTime() || 0;
  }

  async getDebugInfo() {
    const videoDebugInfo = this.renderer ? await this.renderer.getDebugInfo() : null;

    return {
      trackData: {
        duration: this.duration,
        audio: this.audioPlayer ? {
          codec: this.audioPlayer.audioConfig?.codec,
          sampleRate: this.audioPlayer.audioConfig?.sampleRate,
          numberOfChannels: this.audioPlayer.audioConfig?.numberOfChannels,
          startTime: this.audioPlayer.startTime,
          pauseTime: this.audioPlayer.pauseTime,
          isPlaying: this.audioPlayer.isPlaying,
          loadedSegments: this.audioPlayer.audioSegments.size,
          scheduledNodeCount: this.audioPlayer.scheduledNodes.size
        } : null,
        video: videoDebugInfo ? {
          duration: this.renderer?.duration,
          codec: this.trackData?.video?.codec,
          width: this.trackData?.video?.codedWidth,
          height: this.trackData?.video?.codedHeight,
          frameRate: this.trackData?.video?.frameRate,
          ...videoDebugInfo
        } : null
      },
      clock: {
        isPlaying: this.clock?.playing(),
        currentTime: this.getCurrentTime()
      }
    };
  }

  terminate(){
    // Clean up clock
    if (this.clock) {
      this.clock.destroy();
      this.clock = null;
    }

    // Clean up audio resources
    if (this.audioPlayer) {
      this.audioPlayer.pause();
      // Any additional cleanup for audio...
    }

    // Clean up renderer resources
    if (this.renderer) {
      if (this.renderer instanceof VideoWorker) {
        this.renderer.terminate();
      } else {
        this.renderer.terminate();
      }
      this.renderer = null;
    }

    this.emit('terminated');
  }

  async initialize(): Promise<void> {

    console.log("Initializing");

    // Create file demuxer worker
    this.worker = new WorkerController(workerUrl);

    // Create MessageChannel for file worker <-> video worker communication
    const videoChannel = new MessageChannel();

    // Initialize file worker with video port
    await this.worker.sendMessage('init', {
      file: this.file,
      videoPort: videoChannel.port1
    }, [videoChannel.port1]);

    // Get track metadata from file worker
    const trackData = <TrackData> await this.worker.sendMessage('get-tracks', {});
    console.log("Track data", trackData);

    this.trackData = trackData;
    this.duration = trackData.duration;

    // Initialize video worker with port to file worker
    this.renderer = new VideoWorker({
      src: this.file,
      canvas: this.canvas!,
      fileWorkerPort: videoChannel.port2
    });

    await this.renderer.initialize();

    // Send track metadata to video worker
    await this.renderer.setTrackData(trackData.video!, trackData.duration);

    // Create clock to manage playback timing
    // The clock coordinates audio and video using the audio timeline as source of truth
    this.clock = new Clock(this.renderer, this.duration);

    // Initialize audio player with file worker and clock
    // Audio player subscribes to clock's tick events for segment preloading
    this.audioPlayer = new WebAudioPlayer({
      worker: this.worker,
      audioConfig: trackData.audio!,
      duration: trackData.duration,
      file: this.file,
      clock: this.clock
    });

    // Set the audio player as the clock's time source
    this.clock.setAudioPlayer(this.audioPlayer);

    // Forward clock events to external listeners
    this.clock.on('tick', (time) => {
      this.emit('timeupdate', time);
    });

    this.clock.on('play', () => {
      this.emit('play');
    });

    this.clock.on('pause', () => {
      this.emit('pause');
    });

    this.clock.on('ended', () => {
      this.emit('ended');
    });
  }

  // Add more methods as needed
}

export default WebCodecsPlayer; 