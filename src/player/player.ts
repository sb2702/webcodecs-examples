import { VideoTrackData } from "./renderers/video/decoder";
import EventEmitter from "../utils/EventEmitter";
import { WorkerController } from '../utils/WorkerController';
import { AudioTrackData, WebAudioPlayer } from "./renderers/audio/audio";
import { VideoWorker } from "./renderers/video/video";
import workerUrl from './file.ts?worker&url';
// Note to Claude: Do not edit this file or make suggestions unless I specifically ask you to.

export interface WebCodecsPlayerParams {
  src: File;
  canvas: HTMLCanvasElement;
}


export interface TrackData {
  duration: number,
  audio?: AudioTrackData
  video?: VideoTrackData
}





export class WebCodecsPlayer extends EventEmitter {
  private canvas: HTMLCanvasElement | null = null;
  private params: WebCodecsPlayerParams;
  private file: File;
  duration: number = 0;
  private renderer: VideoWorker | null = null;
  private audioPlayer: WebAudioPlayer | null = null;
  private worker: WorkerController | null = null;
  constructor(params: WebCodecsPlayerParams) {
    super();
 

    this.params = params;
    this.worker = new WorkerController(workerUrl);
    this.file = params.src;
    this.canvas = params.canvas;
    this.duration = 0;
    
  



  }

  private setupWorkers() {
    // Create message channels for worker communication
  
  }



  async play() {


    console.log("Playing audio");
  
    await this.audioPlayer?.play();

    this.emit('play', this.audioPlayer?.getCurrentTime());


  }

  async pause() {

    await this.audioPlayer?.pause();

    this.emit('pause', this.audioPlayer?.getCurrentTime());

  }

  async seek(time: number){

    this.renderer?.seek(time);
    await this.audioPlayer?.seek(time);

  }

  terminate(){
    // Clean up audio resources
    if (this.audioPlayer) {
      this.audioPlayer.pause();
      // Any additional cleanup for audio...
    }
    
    // Clean up renderer resources
    if (this.renderer) {
      if (this.renderer instanceof VideoWorker) {
        this.renderer.terminate();
      } else {
        this.renderer.terminate();
      }
      this.renderer = null;
    }

    
    this.emit('terminated');
  }

  async initialize(): Promise<void> {

    console.log("Initializing");

    this.worker = new WorkerController(workerUrl);

    // Use the worker-based renderer
    this.renderer = new VideoWorker({
      src: this.file,
      canvas: this.canvas!
    });

    // Initialize the renderer
    await this.renderer.initialize();
    



    console.log("Getting track data");
    
    const trackData = <TrackData> await this.renderer?.getTrackData();

    console.log("Track data", trackData);

    this.duration = trackData.duration;
    console.log("Audio config", trackData.audio);
    
    this.audioPlayer = new WebAudioPlayer({
      worker: this.worker,
      audioConfig: trackData.audio!,
      duration: trackData.duration,
      file: this.file
    });
    
    // Set up time synchronization
    this.audioPlayer.on('time', (time) => {
      this.emit('timeupdate', time);


      this.renderer?.render(time);
    });
    

    
  }

  // Add more methods as needed
}

export default WebCodecsPlayer; 